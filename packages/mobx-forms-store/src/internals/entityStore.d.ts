import { Progress } from '../utils/progress';
import { EntityStatus, EntityTypeCfg, ILogStorage, IOfflineStore, IOnlineStore, UpdateOptions } from '../interfaces';
import { Queue } from '../utils/queue';
import { EntityMetaProvider, EntityPropMeta, EntityTypeMeta } from './meta';
import { ILazyWrapper } from '../utils/lazy';
import { EntityMerger } from './entityMerger';
import { IEntityStore } from './interfaces';
export declare class Entity<T> {
    __id: any;
    __store: EntityStore<T>;
    __version: number;
    __serverValues: T;
    __clientValues: T;
    __status: EntityStatus;
    __queue: Queue;
    __saveQueue: Queue;
    __loadedOfflineChanges: any;
    __loadedOnlineVersion: any;
    __isNew: any;
    __valuesWrapper: any;
    readonly saveQueue: Queue;
    constructor(store: EntityStore<T>, _id: any);
    pushToServer(waitServerSave: boolean): Promise<any>;
    setClientValues(newValues: T, final: boolean, waitServer: boolean): Promise<any>;
    saveFieldOffline(field: any, value: any): Promise<any>;
    resetValues(): Promise<void>;
    refreshValues(): Promise<void>;
    ensureLoaded(fields?: string[]): Promise<void>;
    getValues(): T;
    importOfflineValues(newValues: OfflineDataItem<T>): void;
    __setServerValuesIfExpired(newValues: T): boolean;
    importOnlineServerValues(newValues: T): void;
    isCreatedOffline(): any;
    private __saveImportedValueOffline;
    private __importOfflineValues;
    private __ensureLoaded;
    private __canGetValues;
    private __getValues;
    ____getOrCreateWrapper(): any;
    __updateClientValues(): void;
    __getClientValues(): any;
    private __saveFieldOffline;
    private __saveOffline;
    private __pushToServer;
    private logError;
    private log;
    private __setClientValues;
    private __refreshValues;
    private __resetValues;
    private _ensureLazyLoaded;
}
export declare class LazyWrapper implements ILazyWrapper {
    lazyfieldNames: string[];
    provider: EntityMetaProvider;
    private typeName;
    constructor(typeName: any, provider: EntityMetaProvider);
    wrapLazyFields<T>(t: T): T;
    unwrapLazyFields<T>(t: T): T;
    getLazyFieldNames(): string[];
}
export declare class OfflineDataItem<T> {
    id: string;
    serverValues: T;
    clientValues: T;
    status: EntityStatus;
    isNew: any;
}
export declare class EntityStore<T> implements IEntityStore<T> {
    _cache: {};
    offlineStore: IOfflineStore<T>;
    onlineStore: IOnlineStore<T>;
    entityWrapCtor: any;
    idField: any;
    merger: EntityMerger;
    type: EntityTypeMeta;
    _allOfflineLoaded: Promise<void>;
    _allOnlineLoaded: Promise<any>;
    logStorage: ILogStorage<T>;
    wrapper: LazyWrapper;
    _saveDelay: 3000;
    constructor(typeCfg: EntityTypeCfg, offlineStore: IOfflineStore<T>, onlineStore: IOnlineStore<T>, logStorage?: ILogStorage<T>);
    initialize(metaProvider: EntityMetaProvider): void;
    loadFieldValue(entityId: any, field: string): Promise<T>;
    getOrCreate(id: any): Entity<T>;
    saveLoadedFieldOffline(entityId: any, field: any, value: any): Promise<any>;
    isDirty(id: any): boolean;
    merge(currentVals: any, newVals: any): any;
    loadOfflineChanges(): Promise<void>;
    resetChanges(id: any): Promise<T>;
    refreshItem(id: any): Promise<T>;
    addOrUpdate(newValues: T, o?: UpdateOptions): Promise<T>;
    isCreatedOffline(id: any): any;
    queryAll(url: any, params?: any): Promise<T[]>;
    getVersionProp(): EntityPropMeta;
    query(url: any, params?: any, force?: any): Promise<T[]>;
    import(obj: T): T;
    getAllOfflines(): Promise<T[]>;
    __getAllOfflines(): Promise<void>;
    getCachedOrLoad(id: any): T;
    getCached(id: any): T;
    getItem(id: any, fields?: string[]): Promise<T>;
    getChanges(onlyFinal?: any): Promise<T[]>;
    pushChangesToServer(throwOnError?: any, p?: Progress): Promise<void>;
    preloadItemsArray(ids: any[]): Promise<T[]>;
    getItemsArray(ids: any[], fields?: string[]): Promise<T[]>;
    private log;
    listen(entity: any): void;
}
